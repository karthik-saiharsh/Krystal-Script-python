'''
This is the official source code for Krystal script
Author: I.Karthik Saiharsh
lisence: MIT
Date of creation: 26 August 2023
'''

# Imports
import sys
import re
import os

## File Imports
import stdlibks
## File Imports
# Imports

args = sys.argv # Getting arguments from user

################## ARGPARSE ##############
# Validating to check if the arguments passed in are proper
if len(args) != 3:
    print(f"\033[0;31mExpected 2 arguments, recieved {len(args)}\033[0;0m")
elif len(args) == 3:
    if args[2] not in ("linux", "windows"):
        print(f"\033[0;31mUnrecognized Operating System {args[2]}\033[0;0m")
    elif args[1][-3::] != ".ks":
        print(f"\033[0;31mUnrecognized file {args[1]}\033[0;0m")
    else:
        print(f"\033[0;32mLoaded File: {args[1]}\nOperating System set to: {args[2]}\033[0;0m")
################## ARGPARSE ##############

# Reading the code file and loading it into memory
filename = f"{args[1][:-3]}.sh" if args[2] == "linux" else f"{args[1][:-3]}.ps1"
try:
    with open(args[1], "r") as code:
        code = code.read().splitlines()
    with open(filename, "w") as f:
        f.write("# Code Generated by Krystal Transpiler\n")
except:
    print(f"\033[0;31mUnable to open file: {args[1]}\033[0;0m")


############## FUNCTIONS ################
def write_code(code: str):
    # Appends code to the generated shell script
    with open(filename, "a") as f:
        f.write(f"{code}\n")
############## FUNCTIONS ################


################# TOKENS #######################
COM = "Com:"
COMMENT = "~Com:"
FOUND_ERROR = False
MULTI_LINE_COMMENT = "MCom"
IS_MCOM = False
IS_IN_TILDA_SCOPE_WIN = False
IS_IN_TILDA_SCOPE_LINUX = False
TILDA_WIN = "~win"
TILDA_LINUX = "~linux"
DISPLAY_PATTERN = "^display"
MAKEFILE_PATTERN = "^makefile"
MAKEFOLDER_PATTERN = "^makefolder"
################# TOKENS #######################


################### CODE PARSER ################
# Reading the code, one line at a time
for line in code:
    line = line.strip()

    # Writing conditional logic to see if the line matches any tokens
    if line == "" or line[:4] == COM:
        # Continue if the line is empty or a comment
        continue
    
    ###### TOGGLE STATEMENTS ######
    elif line == MULTI_LINE_COMMENT:
        IS_MCOM = not IS_MCOM
        continue

    elif line == TILDA_LINUX:
        IS_IN_TILDA_SCOPE_LINUX = not IS_IN_TILDA_SCOPE_LINUX
        continue

    elif line == TILDA_WIN:
        IS_IN_TILDA_SCOPE_WIN = not IS_IN_TILDA_SCOPE_WIN
        continue
    ###### TOGGLE STATEMENTS ######

    ###### TOGGLE CONDITIONS ######
    elif IS_MCOM:
        write_code(f"#{line}")
        continue

    elif IS_IN_TILDA_SCOPE_LINUX:
        if args[2] == "linux":
            write_code(line)
            continue
        else:
            continue

    elif IS_IN_TILDA_SCOPE_WIN:
        if args[2] == "windows":
            write_code(line)
            continue
        else:
            continue
    ###### TOGGLE CONDITIONS ######


    ########## MAIN CODE ##########

    elif line[:5] == COMMENT:
        write_code(f"#{line[5::]}")

    elif re.search(DISPLAY_PATTERN, line.lower()):
        if (gen_code := stdlibks.Display_fn(line, args[2])) != "err":
            write_code(gen_code)
        else:
            FOUND_ERROR = True
    
    elif re.search(MAKEFILE_PATTERN, line.lower()):
        if (gen_code := stdlibks.MakeFile(line, args[2])) != "err":
            write_code(gen_code)
        else:
            FOUND_ERROR = True

    elif re.search(MAKEFOLDER_PATTERN, line.lower()):
        if (gen_code := stdlibks.MakeFolder(line, args[2])) != "err":
            write_code(gen_code)
        else:
            FOUND_ERROR = True
    
    else:
        FOUND_ERROR = True



if FOUND_ERROR:
    # delete the generated file if an error is found
    print(f"\033[0;31mError on line {code.index(line)+1}: {line}\033[0;0m")
    os.remove(filename)